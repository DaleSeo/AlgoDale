---
title: "Longest Repeating Character Replacement"
tags:
  - leetcode
  - string
  - sliding-window
  - two-pointers
  - python
date: 2024-05-30
---

LeetCode의 424번째 문제인 [Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/)를 함께 풀어보도록 하겠습니다.

## 문제

문자열이 주어졌을 때 반복되는 글자를 포함하지 않는 가장 긴 부분 문자열(substring)의 길이를 구하라.

당신은 문자열 `s`와 정수 `k`가 주어집니다.
당신은 문자열에서 글자 하나를 골라서 다른 영어 대문자 바꿀 수 있으며, 이 작업을 최대 `k`번 수행할 수 있습니다.

이러한 작업들을 수행하여 얻을 수 있는 동일한 글자로 이루어진 가장 긴 부분 문자열의 길이를 반환하시오.

## 예제

```py
Input: s = "ABAB", k = 2
Output: 4
```

```py
Input: s = "AABABBA", k = 1
Output: 4
```

## 풀이

어떤 문자열이 주어졌을 때 어떻게 하면 가장 작은 수의 글자를 바꿔서 해당 문자열이 모두 동일한 글자로 이뤄지게 만들 수 있을까요?
바로 문자열에 가장 많이 들어있는 글자로 다른 글자들까지 모두 통일 시켜주는 것입니다.

예를 들어, `A`가 3개와 `B`가 2개로 이루어진 `AABAB`가 주어졌다고 가정해봅시다.
그 문자열은 `AAAAA`로 만들 수도 있고, `BBBBB`로 만들 수도 있을텐데요.
`B` 글자 2개를 `A`로 바꾸는 것이, `A` 글자 3개를 `B`로 바꾸는 것보다 적은 노력이 들어갑니다.

그러므로 우리는 문자열 안에 각 글자가 몇 번씩 나왔는지 해시 테이블 자료 구조에 저장을 해야할 것입니다.
글자를 바꾸기 전에 어떤 글자가 가장 많이 나왔는지 알아야하기 때문입니다.

그럼 글자를 바꾸는 횟수가 제한되어 있을 때 어떻게하면 가장 효과적으로 바꿀 수 있을까요?
즉, 동일한 문자로 이루어진 가장 긴 부분 문자열을 만들 수 있는 지점에서 글자를 바꿔야 합니다.

이 문제처럼 부분 문자열을 찾을 때 매우 효율적인 풀이 기법이 있는데요.
바로 슬라이딩 윈도우(Sliding Window)입니다.

기본 아이디어는 두 개의 포인터를 사용하여 부분 문자열의 시작과 끝을 가리키게 하고,
윈도우의 길이를 유기적으로 늘렸다가 줄였다가 하면서 전체 문자열을 탐색해나가는 것입니다.

문제에서 주어진 두 번째 예제로 같이 차근차근 같이 생각을 해볼까요?

우선 두 개의 포인터를 모두 인덱스 `0`에 놓도록 하겠습니다.
두 개의 포인터가 가리키는 2개의 글자까지 부분 문자열에 포함시킵니다.

```py
_
AABABBA => "A" => 길이 1 (시작 인덱스 0, 종료 인덱스 0)
카운터: {A: 1}
```

부분 문자열에 글자가 하나 밖에 없을 때 바꾸는 작업이 아무 의미가 없습니다.
아무리 글자를 바꾸어도 언제나 같은 글자로 이루어져 있기 때문입니다.

```py
__
AABABBA => "AA" => 길이 2 (시작 인덱스 0, 종료 인덱스 1)
카운터: {A: 2}
```

종료 인덱스를 증가시키면, 부분 문자열은 `A` 글자 `2`개로 이루어집니다.
같은 글자로만 이루어져 있기 때문에 역시 어떤 글자로 바꿀 이유가 없습니다.

```py
___
AABABBA => "AAB" => 길이 3 (시작 인덱스 0, 종료 인덱스 2)
카운터: {A: 2, B: 1}
부분 문자열의 길이 - 가장 많이 들어있는 글자의 수 = 3 - 2 = 1 == 1
```

종료 인덱스를 증가시키니, 부분 문자열에 처음으로 `B` 글자가 들어옵니다.
이 부분 문자열 안에 가장 많이 들어있는 문자는 `A`이므로, `B`를 `A`로 바꿔야 합니다.

그래서 이때, 부분 문자열의 길이에서 가장 많이 들어있는 글자의 수를 뺀 값이 `k`를 넘지 않는지 확인해야 합니다.
여기서는 부분 문자열의 길이가 `3`이고 가장 많이 들어있는 `A`의 개수가 `2`이므로, 이 둘을 빼면 `1`, 즉 `k`를 넘지 않습니다.

```py
____
AABABBA => "AABA" => 길이 4 (시작 인덱스 0, 종료 인덱스 3)
카운터: {A: 3, B: 1}
부분 문자열의 길이 - 가장 많이 들어있는 글자의 수 = 4 - 3 = 1 == 1
```

종료 인덱스를 증가시키니, 부분 문자열에 `A` 글자가 들어옵니다.
이 부분 문자열 안에 가장 많이 들어있는 문자는 여전히 `A`이므로, `B`를 `A`로 바꿔야 합니다.

이전 단계와 동일한 방식으로 부분 문자열의 길이에서 가장 많이 들어있는 글자의 수를 빼면 아직, `k`를 넘지는 않습니다.

```py
_____
AABABBA => "AABAB" => 길이 5 (시작 인덱스 0, 종료 인덱스 4)
카운터: {A: 3, B: 2}
부분 문자열의 길이 - 가장 많이 들어있는 글자의 수 = 5 - 3 = 2 > 1
```

종료 인덱스를 증가시키니, 부분 문자열에 다시 `B` 글자가 들어옵니다.
이 부분 문자열 안에 가장 많이 들어있는 문자는 여전히 `A`이므로, `B`를 `A`로 바꿔야 하는데요.

이번에는 이전 단계와 다르게 부분 문자열의 길이에서 가장 많이 들어있는 글자의 수를 뺀 값이 `k`보다 커집니다.
따라서 우리는 시작 인덱스를 증가시켜서 문자열의 길이를 줄여줘야 합니다.

```py
 ____
AABABBA => "AABAB" => 길이 4 (시작 인덱스 1, 종료 인덱스 4)
카운터: {A: 2, B: 2}
부분 문자열의 길이 - 가장 많이 들어있는 글자의 수 = 4 - 2 = 2 > 1
```

시작 인덱스를 증가시키니, 부분 문자열에 `A` 글자가 빠집니다.
이 부분 문자열 안에는 `A`와 `B`가 동일하게 `2`개씩 들어 있습니다.

여전히 부분 문자열의 길이에서 가장 많이 들어있는 글자의 수를 뺀 값이 `k`보다 큽니다.
따라서 우리는 시작 인덱스를 증가시켜서 문자열의 길이를 줄여줘야 합니다.

```py
  ___
AABABBA => "AABAB" => 길이 3 (시작 인덱스 2, 종료 인덱스 4)
카운터: {A: 1, B: 2}
부분 문자열의 길이 - 가장 많이 들어있는 글자의 수 = 3 - 2 = 1 == 1
```

시작 인덱스를 증가시키니, 부분 문자열에 `A` 글자가 빠집니다.
이제 부분 문자열 안에는 `B`가 `2`개로 가장 많이 들어 있습니다.

부분 문자열의 길이에서 가장 많이 들어있는 글자의 수를 빼면 `k`와 같아 집니다.
따라서 우리는 종료 인덱스를 증가시켜서 문자열의 길이를 늘려줘야 합니다.

```py
  ____
AABABBA => "AABAB" => 길이 4 (시작 인덱스 2, 종료 인덱스 5)
카운터: {A: 1, B: 3}
부분 문자열의 길이 - 가장 많이 들어있는 글자의 수 = 4 - 3 = 1 == 1
```

종료 인덱스를 증가시키니, 부분 문자열에 `B` 글자가 들어옵니다.
이 부분 문자열 안에 가장 많이 들어있는 문자는 여전히 `B`이므로, `A`를 `B`로 바꿔야 합니다.

여기서는 부분 문자열의 길이가 `4`이고 가장 많이 들어있는 `B`의 개수가 `3`이므로, 이 둘을 빼면 `1`, 즉 `k`를 넘지 않습니다.
또 종료 인덱스를 증가시킬 수 있습니다.

위와 같은 과정을 반복하면서 슬라이딩 윈도우를 왼쪽에서 오른쪽 끝까지 움직이면서 `k`번 글자를 바꿔서 만들 수 있는 같은 문자로 이루어진 가장 긴 문자열을 찾을 수 있을 것입니다.
이 알고리즘을 파이썬으로 구현해보겠습니다.

```py
class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        max_len = 0
        counter = {}
        start, end = 0, 0
        while end < len(s):
            counter[s[end]] = counter.get(s[end], 0) + 1
            while end - start + 1 - max(counter.values()) > k:
                counter[s[start]] -= 1
                start += 1
            max_len = max(end - start + 1, max_len)
            end += 1
        return max_len
```

종료 인덱스는 항상 1씩 증가하니, `while` 문 대신에 `for` 문을 써도 되겠네요.

```py
class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        max_len = 0
        counter = {}
        start = 0
        for end in range(len(s)):
            counter[s[end]] = counter.get(s[end], 0) + 1
            while end - start + 1 - max(counter.values()) > k:
                counter[s[start]] -= 1
                start += 1
            max_len = max(end - start + 1, max_len)
        return max_len
```

## 마치면서

이 문제가 너무 어려우셨다면 비슷하지만 좀 더 쉬운 문제인 [Longest Substring Without Repeating Characters](/problems/longest-substring-without-repeating-characters/)도 풀어보시라고 추천드립니다.
