---
title: "Count Primes"
tags:
  - leetcode
  - prime
  - array
  - set
  - python
date: 2024-02-24
---

LeetCode의 204번째 문제인 [Count Primes](https://leetcode.com/problems/count-primes/)를 함께 풀어보도록 하겠습니다.

## 문제

정수 `n`이 주어졌을 때, `n`보다 작은 소수의 개수를 반환하라

## 예제

```py
Input: n = 10
Output: 4
```

```py
Input: n = 0
Output: 0
```

```py
Input: n = 1
Output: 0
```

## 풀이 1

소수(Prime Number)란 1를 제외한 약수가 자기 자신 밖에 없는 정수를 뜻합니다.
다시 말해서, 약수가 1과 자기 자신, 이렇게 단 두 개만 있는 수가 바로 소수입니다.

예를 들어, `2`, `3`, `5`, `7`은 대표적인 소수입니다.
이 숫자들은 모두 1과 자신 외에는 다른 수로 나누어지지 않습니다.

어떤 정수 `n`이 주어졌을 때 이 수가 소수인지 어떻게 알아낼 수 있을까요?
주어진 수를 1과 자기 자신 사이에 있는 모든 정수로 나눠보면 알겠죠?
즉, `2`부터 `n-1`까지 루프를 돌면서 1씩 증가시면서 `n`으로 나누었을 때 나머지가 `0`인지 확인해보면 될 것입니다.
만약에 나눴을 때 나머지가 `0`인 경우가 있다면, 그 수는 소수가 아닐 것입니다.
루프를 끝까지 돌 때 까지 그런 수가 없다면 그 수는 소수일 것입니다.

그런데 여기서 조금만 더 생각을 해보면 굳이 `n-1`까지 나눌 필요는 없다는 것을 깨닫게 되는데요.
`n`의 제곱근까지만 나누어봐도 충분하기 때문입니다.
`n`의 제곱근보다 큰 정수 중에서 약수가 있다면, `n`의 제곱근보다 작은 정수 중에서 100% 그 약수와 짝이 되는 다른 약수가 있기 때문이죠.

예를 들어, `18`의 제곱근은 약 `4.2`인데요.
약수 `2`는 `4.2`보다 작고, 그와 짝이 되는 `9`는 `4.2`보다 큽니다.
약수 `3`은 `4.2`보다 작고, 그와 짝이 되는 `6`는 `4.2`보다 큽니다.

그러므로 제곱근까지만 나누었을 때 약수가 나오지 않았다면, 제곱근보다 큰 숫자로 나누는 것은 의미가 없다는 것을 알 수 있습니다.
어차피 약수의 짝이 없을테니까요.

지금까지 설명드린 약수 판별 로직을 별도의 함수로 구현하면, 정수 `n`보다 작은 소수는 `2`부터 `n-1`의 숫자를 상대로 이 함수를 호출하기만 하면 셀 수 있습니다.

```py
class Solution:
    def countPrimes(self, n: int) -> int:
        def is_prime(num):
            for divisor in range(2, int(num**0.5) + 1):
                if num % divisor == 0:
                    return False
            return True

        cnt = 0
        for num in range(2, n):
            if is_prime(num):
                cnt += 1
        return cnt
```

이 풀이의 시간 복잡도는 약수를 판별하는데 `O(sqrt(n))`의 시간이 걸리므로 `O(n * sqrt(n))`이 됩니다.
추가 공간을 사용하지 않으므로 공간 복잡도는 `O(1)`이 되겠습니다.

## 풀이 2

이 문제를 좀 더 효율적으로 푸는 방법은 유명한 알고리즘인 에라토스테네스의 체(Sieve of Eratosthenes)를 사용하는 것입니다.

에라토스테네스의 체는 마치 체로 숫자들을 털어내듯이 소수만 남을 때까지 소수인 반대인 합성수(Composite Number)를 걸러냅니다.

예를 들어, 26보다 작은 소수를 에라토스테네스의 체를 이용해서 찾아보겠습니다.

맨 처음에는, 2부터 19까지 모두 소수가 될 수 있다고 가정하고 체에 올려놓습니다.

```py
{2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26}
```

우선 2를 제외한 2의 배수를 체에서 털어냅니다.

```py
  {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26}
- {4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26}
= {2, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25}
```

다음으로 3를 제외한 3의 배수를 체에서 털어냅니다.

```py
  {2, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25}
- {6, 9, 12, 15, 18, 21, 24}
= {2, 3, 5, 7, 11, 13, 17, 19, 23, 25}
```

4의 배수는 이미 2의 배수를 털어낼 때 털어냈으므로 굳이 다시 털어내봤자 아무 의미가 없을 것입니다.
따라서 5를 제외한 5의 배수를 체에서 털어냅니다.

```py
  {2, 3, 5, 7, 11, 13, 17, 19, 23, 25}
- {10, 15, 20, 25}
= {2, 3, 5, 7, 11, 13, 17, 19, 23}
```

25의 제곱근은 5이므로 6의 배수부터는 체어서 털어낼 필요가 없습니다.

에라토스테네스의 체는 배열을 이용해서 구현하는 경우가 많습니다.
따라서 [배열(Array)](/data-structures/array/)을 이용해서 구현해보겠습니다.

```py
class Solution:
    def countPrimes(self, n: int) -> int:
        is_prime = [True] * n
        for num in range(2, int(n**0.5) + 1):
            if is_prime[num]:
                for composite in range(num**2, n, num):
                    is_prime[composite] = False
        return len([p for p in range(2, n) if is_prime[p]])
```

[집합(Set)](/data-structures/set/)을 활용하여 에라토스테네스의 체를 조금 더 깔끔하게 구현할 수도 있습니다.

```py
class Solution:
    def countPrimes(self, n: int) -> int:
        primes = set(range(2, n))
        for num in range(2, int(n**0.5) + 1):
            if num in primes:
                primes -= set(range(num * 2, n, num))
        return len(primes)
```

에라토스테네스의 체 알고리즘의 복잡도는 `O(n * log(log n))`으로 알려져있습니다.
공간 복잡도는 `n`과 비례해서 커지는 배열 또는 집합을 사용하기 때문에 `O(n)`이 되겠습니다.
