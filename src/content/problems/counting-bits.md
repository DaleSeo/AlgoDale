---
title: "Counting Bits"
tags:
  - leetcode
  - string
  - bitManipulation
  - dp
  - python
  - javascript
date: 2024-05-13
---

LeetCode의 338번째 문제인 [Counting Bits](https://leetcode.com/problems/counting-bits/) 문제를 함께 풀어보도록 하겠습니다.

## 문제

정수 `n`이 주어졌을 때, 길이가 `n + 1`인 배열 `ans`를 반환하시오.
`ans[i]`는 `i`에 대한 이진수로 표현했을 때, `1`의 개수를 담고 있어야 합니다.

## 예제

```py
입력: n = 2
출력: [0,1,1]
```

```py
입력: n = 5
출력: [0,1,1,2,1,2]
```

## 풀이 1

```py
class Solution:
    def countBits(self, n: int) -> List[int]:
        def count(n):
            cnt = 0
            while n:
                cnt += n % 2
                n //= 2
            return cnt

        return [count(num) for num in range(n + 1)]
```

이 풀이의 시간 복잡도는 `O(n * log n)`이 되는데요.
`1`의 개수를 세어주는 내부 함수의 복잡도가 `O(log n)`인데, 이 작업을 `n + 1`번 수행해야하기 때문입니다.

변환된 공간 복잡도는 결과 배열을 제외하면 고정된 개수의 변수만 사용하므로 `O(1)`이 되겠습니다.

## 풀이 2

이전 풀이를 보면 `2`로 나누고 나머지를 구하는 작업을 `0`부터 `n`까지 모든 숫자를 상대로 하고 있기 때문에 상당히 비효율적입니다.
어떻게 하면 더 작은 숫자를 상대로 구한 이진수 내의 `1`의 개수를 더 큰 숫자를 상대로 구할 때 활용할 수 있을까요?

우리 한번 `0`부터 `15`까지의 이진수를 구해서 표로 나타내보겠습니다.

| 십진수 | 이진수 | 패턴    |
| ------ | ------ | ------- |
| 0      | 0000   | 0       |
| 1      | 0001   | 1       |
| 2      | 0010   | 1 + 0   |
| 3      | 0011   | 1 + 1   |
| 4      | 0100   | 1 + 00  |
| 5      | 0101   | 1 + 01  |
| 6      | 0110   | 1 + 10  |
| 7      | 0111   | 1 + 11  |
| 8      | 1000   | 1 + 000 |
| 9      | 1001   | 1 + 001 |
| 10     | 1010   | 1 + 010 |
| 11     | 1011   | 1 + 011 |
| 12     | 1100   | 1 + 100 |
| 13     | 1101   | 1 + 101 |
| 14     | 1110   | 1 + 110 |
| 15     | 1111   | 1 + 111 |

위 표를 자세히 살펴 보시면 다음과 같이 반복되는 패턴을 찾으실 수 있으실 거에요.
숫자가 2배가 될 때 마다 이진수로 나타내었을 때 맨 앞에 새로운 `1`이 붙게 되기 때문이죠.

- `1`의 이진수 내의 `1`의 개수 = `1` + `0`의 이진수 내의 `1`의 개수
- `2`부터 `3` 사이의 이진수 내의 `1`의 개수 = `1` + `0`부터 `1` 사이의 이진수 내의 `1`의 개수
- `4`부터 `7` 사이의 이진수 내의 `1`의 개수 = `1` + `0`부터 `3` 사이의 이진수 내의 `1`의 개수
- `8`부터 `15` 사이의 이진수 내의 `1`의 개수 = `1` + `0`부터 `7` 사이의 이진수 내의 `1`의 개수

이 패턴을 수식으로 나타내보면 `arr[i] = 1 + arr[i - base]`게 될텐데요.
여기서 `base`는 `1, 2, 4, 8, 16, ...` 식으로 `2`배씩 커지게 되는데, 숫자가 커질수록 `base`가 천천히 커지는 것을 볼 수 있습니다.
정확히 얘기하면 숫자가 기존 `base`의 정확히 `2`배가 될 때마다 `base`가 `2` 배로 늘어나게 됩니다.

| 십진수 | 이진수 | base | 1의 개수           |
| ------ | ------ | ---- | ------------------ |
| 0      | 0      |      | 0                  |
| 1      | 1      | 1    | 1 + dp[1 - 1] = 1  |
| 2      | 10     | 2    | 1 + dp[2 - 2] = 1  |
| 3      | 11     | 2    | 1 + dp[3 - 2] = 2  |
| 4      | 100    | 4    | 1 + dp[4 - 4] = 1  |
| 5      | 101    | 4    | 1 + dp[5 - 4] = 2  |
| 6      | 110    | 4    | 1 + dp[6 - 4] = 2  |
| 7      | 111    | 4    | 1 + dp[7 - 4] = 3  |
| 8      | 1000   | 8    | 1 + dp[8 - 8] = 1  |
| 9      | 1001   | 8    | 1 + dp[9 - 8] = 2  |
| 10     | 1010   | 8    | 1 + dp[10 - 8] = 2 |
| 11     | 1011   | 8    | 1 + dp[11 - 8] = 3 |
| 12     | 1100   | 8    | 1 + dp[12 - 8] = 2 |
| 13     | 1101   | 8    | 1 + dp[13 - 8] = 3 |
| 14     | 1110   | 8    | 1 + dp[14 - 8] = 3 |
| 15     | 1111   | 8    | 1 + dp[15 - 8] = 4 |

결국은 [동적 계획법 (Dynamic Programming)](/algorithms/dp/)으로 해결할 수 있다 문제라는 것을 알 수 있게 되었네요!

지금까지 설명드린 알고리즘을 파이썬으로 구현해보겠습니다.

```py
class Solution:
    def countBits(self, n: int) -> List[int]:
        dp = [0] * (n + 1)
        base = 1
        for num in range(1, n + 1):
            if base * 2 == num:
                base *= 2
            dp[num] = 1 + dp[num - base]
        return dp
```

이 풀이는 단순히 `O(1)`의 시간이 걸리는 로직을 `1`부터 `n`까지 한 번 루프를 돌고 있기 때문에 시간 복잡도가 `O(n)`으로 향상이 됩니다.

## 마치면서

이 문제가 너무 어려우셨다면 비슷하지만 좀 더 쉬운 문제인 [Number of 1 Bits](/problems/number-of-1-bits/)도 풀어보시라고 추천드립니다.
