---
title: "01 Matrix"
tags:
  - leetcode
  - array
  - matrix
  - graph
  - dfs
  - recursion
  - bfs
  - queue
  - python
date: 2023-10-16
---

LeetCode의 542번째 문제인 [01 Matrix](https://leetcode.com/problems/01-matrix/)를 함께 풀어보도록 하겠습니다.

## 문제

주어진 `m x n` 이진 행렬 `mat`에서 각 칸과 가장 가까운 `0` 간의 거리를 반환하시오.
인접한 두 칸 사이의 거리는 1입니다.

## 예제

```py
Input: mat = [[0,0,0],[0,1,0],[0,0,0]]
Output: [[0,0,0],[0,1,0],[0,0,0]]
```

```py
Input: mat = [[0,0,0],[0,1,0],[1,1,1]]
Output: [[0,0,0],[0,1,0],[1,2,1]]
```

## 풀이 1

주어진 행렬에서 간 칸과 가장 가까운 거리에 있는 `0`을 어떻게 찾을 수 있을까요?

첫 번째 예제를 가지고 생각해보면, 행렬의 정 중앙, 즉 `(1, 1)` 위치에 있는 `1`은 8개의 `0`으로 둘러싸여 있는데요.
네 모서리, 즉 `(0, 0)`, `(0, 2)`, `(2, 0)`, `(2, 2)` 위치에 있는 `0`과의 거리는 2입니다.
대각선 방향으로는 한 번에 이동할 수 있기 때문에, `하 -> 우`, `하 -> 좌`, `상 -> 우`, `상 -> 좌`, 이렇게 두 칸을 이동해야하죠.
반면에, 정 중앙에 있는 `1`의 상하좌우, 즉 `(0, 1)`, `(1, 0)`, `(1, 2)`, `(2, 1)` 위치에 있는`0`과의 거리는 1입니다.
따라서, 2보다는 1이 작으므로 가장 가까운 거리는 1이 됩니다.

이 사고 과정을 관찰해보니 이 문제는 [그래프(Graph)](/data-structures/graph/) 자료구조를 활용해서 해결할 수 있을 것 같은데요.
각 칸을 정점(vertex, node), 상하좌우에 있는 칸을 간선(edge)로 보면 주어진 행렬은 그래프로 생각할 수 있기 때문입니다.
그리고 우리는 값이 `0`인 모든 정점에서부터 그래프 탐색을 시작해서 값이 `0`이 아닌 정점에 도달하면 거리가 얼마인지 알 수 있을 것입니다.
여기서 중요한 것은 최소 거리를 구해야하기 때문에 이 전에 해당 정점에 도착했던 `0`과의 거리와 비교해서 더 작은 거리를 선택해야할 것입니다.

그럼 첫 번째 예제보다 살짝 더 복잡한 두 번째 예제로 알고리즘을 설명드려볼께요.

우선 최소 거리를 구하기 용이하도록 행렬에서 `0`이 아닌 칸의 값을 가능한 최대 거리로 갱신해주겠습니다.
3개의 행과 3개의 열로 이루어진 행렬에서 칸 간의 거리는 아무리 크더라도 절대 `3 x 3`를 넘지 못할 것이므로 `9`로 갱신해줄께요.

```py
행렬:
[0, 0, 0]
[0, 9, 0]
[9, 9, 9]
```

다음으로 행렬을 상대로 루프를 돌면서 값이 `0`인 칸을 만나면 그 곳에서 도달할 수 있는 모든 칸의 거리를 측정합니다.

인덱스 `(0, 0)` 주변에는 행렬의 범위를 벗어나거나, `0` 밖에 없는데요.
이럴 경우, 굳이 이 곳에서 부터 거리를 잴 필요는 없습니다.
아래 또는 우측에 있는 `0`에서 거리를 재는 것이 무조건 더 짧을 것이기 때문입니다.
그러므로 우리는 그래프 탐색을 중단하고 행렬에서 다음으로 나오는 `0`인 칸으로 넘어갈 수 있습니다.

```py
mat[0][0] == 0
    - 상 mat[-1][0] 🚫
    - 하 mat[1][0] 👉 0 < 0 + 1
    - 좌 mat[0][-1] 🚫
    - 우 mat[0][0] 👉 0 < 0 + 1

행렬:
[0, 0, 0]
[0, 9, 0]
[9, 9, 9]
```

인덱스 `(0, 1)` 아래에 있는 `(1, 1)`에는 `9`가 있는데요.
여기서부터 탐색을 시작하면 거리가 `1`이 되고, 이것은 `9`보다 작습니다.
따라서 `(1, 1)` 위치의 값을 `1`로 갱신하고, 그 곳에서 추가 탐색을 진행합니다.

```py
mat[0][1] == 0
    - 상 mat[-2][1] 🚫
    - 하 mat[1][1] 👉 9 > 0 + 1 👉 mat[1][1] = 1
    - 좌 mat[0][0] 👉 0 < 0 + 1
    - 우 mat[0][2] 👉 0 < 0 + 1

행렬:
[0, 0, 0]
[0, 1, 0]
[9, 9, 9]
```

인덱스 `(1, 1)` 아래에 있는 `(2, 1)`에는 `9`가 있는데요.
여기서부터 탐색을 시작하면 거리가 `2`이 되고 이 것은 `9`보다 작습니다.
따라서 `(2, 1)` 위치의 값을 `2`로 갱신하고, 그 곳에서 추가 탐색을 진행합니다.

```py
mat[0][1] == 0
    mat[1][1] == 1
        - 상 mat[0][1] 👉 0 < 1 + 1
        - 하 mat[2][1] 👉 9 > 1 + 1 👉 mat[2][1] = 2
        - 좌 mat[1][0] 👉 0 < 1 + 1
        - 우 mat[1][2] 👉 0 < 1 + 1

행렬:
[0, 0, 0]
[0, 1, 0]
[9, 2, 9]
```

인덱스 `(2, 1)` 좌측에 있는 `(2, 0)`과 우측에 있는 `(2, 2)`에는 `9`가 있는데요.
여기서부터 탐색을 시작하면 거리가 `3`이 되고 이 것은 `9`보다 작습니다.
이번에는 추가 탐색을 진행할 곳이 2군데가 생겼는데요.
먼저 `(2, 0)` 위치의 값을 `2`로 갱신하고, 그 곳에서 추가 탐색해보겠습니다.

```py
mat[0][1] == 0
    mat[1][1] == 1
        mat[2][1] == 2
            - 상 mat[1][1] 👉 1 < 2 + 1
            - 하 mat[3][1] 🚫
            - 좌 mat[2][0] 👉 9 > 2 + 1 👉 mat[2][0] = 3
            - 우 mat[2][2] 👉 9 > 2 + 1

행렬:
[0, 0, 0]
[0, 1, 0]
[3, 2, 9]
```

인덱스 `(2, 0)` 주변에는 더 이상 추가 탐색을 할 곳이 보이지 않습니다.
아래랑 좌측은 행렬의 범위를 벗어나고, 위와 오른쪽은 여기서 출발했을 때 거리인 `4`보다 이미 더 짧은 거리가 들어있으니까요.
그러므로 여기서 탐색을 멈추고, 다시 `(2, 1)`로 돌아갑니다.

```py
mat[0][1] == 0
    mat[1][1] == 1
        mat[2][1] == 2
            mat[2][0] == 3
                - 상 mat[1][0] 👉 0 < 3 + 1
                - 하 mat[3][0] 🚫
                - 좌 mat[2][-1] 🚫
                - 우 mat[2][1] 👉 2 < 3 + 1

행렬:
[0, 0, 0]
[0, 1, 0]
[3, 2, 9]
```

인덱스 `(2, 1)` 우측에 있는 `(2, 2)`에 있던 `9`도 마저 `3`으로 갱신해줍니다.
그리고 이 곳에서 남은 탐색을 진행하겠습니다.

```py
mat[0][1] == 0
    mat[1][1] == 1
        mat[2][1] == 2
            - 상 mat[1][1] 👉 1 < 2 + 1
            - 하 mat[3][1] 🚫
            - 좌 mat[2][0] 👉 9 > 2 + 1 👉 mat[2][0] = 3 (탐색 완료)
            - 우 mat[2][2] 👉 9 > 2 + 1 👉 mat[2][2] = 3

행렬:
[0, 0, 0]
[0, 1, 0]
[3, 2, 3]
```

인덱스 `(2, 2)` 주변에도 같은 이유로 더 이상 추가 탐색을 할 곳이 보이지 않습니다.
여기서 `(0, 1)`에서 시작했던 모든 탐색을 중단하고, 다음으로 나오는 `0`인 칸으로 넘어갈 수 있습니다.

```py
mat[0][1] == 0
    mat[1][1] == 1
        mat[2][1] == 2
            mat[2][2] == 3
                - 상 mat[1][2] 👉 0 < 3 + 1
                - 하 mat[3][2] 🚫
                - 좌 mat[2][1] 👉 2 < 3 + 1
                - 우 mat[2][3] 🚫

행렬:
[0, 0, 0]
[0, 1, 0]
[3, 2, 3]
```

인덱스 `(0, 2)` 주변에는 행렬의 범위를 벗어나거나, `0` 밖에 없는데요.
따라서 굳이 이 곳에서 부터 거리를 잴 필요는 없으며, 다음으로 나오는 `0`인 칸으로 넘어갑니다.

```py
mat[0][2] == 0
    - 상 mat[-1][2] 🚫
    - 하 mat[1][2] 👉 0 < 0 + 1
    - 좌 mat[0][1] 👉 0 < 0 + 1
    - 우 mat[0][3] 🚫

행렬:
[0, 0, 0]
[0, 1, 0]
[3, 2, 3]
```

인덱스 `(1, 0)` 아래에 있는 `(2, 0)`에는 `3`이 있는데요.
여기서 출발하면 거리가 `1`이기 되고 이 것은 `3`보다 작습니다.
따라서 `(2, 0)` 위치의 값을 `1`로 갱신하고, 그 곳에서 추가 탐색을 진행합니다.

```py
mat[1][0] == 0
    - 상 mat[0][0] 👉 0 < 0 + 1
    - 하 mat[2][0] 👉 3 > 0 + 1 👉 mat[2][0] = 1
    - 좌 mat[1][-1] 🚫
    - 우 mat[1][1] 👉 1 == 0 + 1

행렬:
[0, 0, 0]
[0, 1, 0]
[1, 2, 3]
```

인덱스 `(2, 0)`부터 탐색을 시작해서 기존 거리보다 더 작은 거리를 얻을 수 있는 곳은 보이지 않습니다.
여기서 탐색을 중단하고, 다음으로 나오는 `0`인 칸으로 넘어갑니다.

```py
mat[1][0] == 0
    mat[2][0] == 1
        - 상 mat[1][0] 👉 0 < 1 + 1
        - 하 mat[3][0] 🚫
        - 좌 mat[2][-1] 🚫
        - 우 mat[2][1] 👉 2 == 1 + 1

행렬:
[0, 0, 0]
[0, 1, 0]
[1, 2, 3]
```

인덱스 `(1, 2)` 아래에 있는 `(2, 2)`에는 `3`이 있는데요.
여기서 출발하면 거리가 `1`이기 되고 이 것은 `3`보다 작습니다.
따라서 `(2, 2)` 위치의 값을 `1`로 갱신하고, 그 곳에서 추가 탐색을 진행합니다.

```py
mat[1][2] == 0
    - 상 mat[0][2] 0 < 0 + 1
    - 하 mat[2][2] 3 > 0 + 1 👉 mat[2][2] < 1
    - 좌 mat[1][1] 1 == 0 + 1
    - 우 mat[1][3] 🚫

행렬:
[0, 0, 0]
[0, 1, 0]
[1, 2, 1]
```

인덱스 `(2, 2)`부터 탐색을 시작해서 기존 거리보다 더 작은 거리를 얻을 수 있는 곳은 보이지 않습니다.
여기서 탐색을 중단하게 되면 행렬에서 더 이상 값이 `0`인 칸은 남지 않습니다.

```py
mat[1][2] == 0
    mat[2][2] == 1
        - 상 mat[1][2] 👉 0 < 1 + 1
        - 하 mat[3][2] 🚫
        - 좌 mat[2][1] 👉 2 == 1 + 1
        - 우 mat[2][3] 🚫

행렬:
[0, 0, 0]
[0, 1, 0]
[1, 2, 1]
```

이로써 행렬에 있는 모든 `0`에 상대로 한 루프가 종료되고, 원하는 모습의 결과 형렬을 얻게 되었습니다.

이 깊이 우선 탐색 알고리즘을 재귀를 이용하여 파이썬으로 구현해보겠습니다.

```py
class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        n_rows, n_cols = len(mat), len(mat[0])

        def dfs(row, col):
            for r, c in [(0, -1), (0, 1), (-1, 0), (1, 0)]:
                if 0 <= row + r < n_rows and 0 <= col + c < n_cols:
                    if mat[row + r][col + c] > mat[row][col] + 1:
                        mat[row + r][col + c] = mat[row][col] + 1
                        dfs(row + r, col + c)

        for r in range(n_rows):
            for c in range(n_cols):
                if mat[r][c] != 0:
                    mat[r][c] = n_rows * n_cols

        for r in range(n_rows):
            for c in range(n_cols):
                if mat[r][c] == 0:
                    dfs(r, c)

        return mat
```

주어진 입력 행렬의 행의 수를 `r`, 열의 수를 `c`라고 했을 때, 이 풀이의 시간 복잡도는 `O((r * c)^2)`이 되는데요.
`(2, 0)`과 `(2, 2)` 경우처럼, 하나의 칸을 두 번 이상 방문하여 더 작은 거리로 갱신할 수 있기 때문입니다.
공간 복잡도는 재귀 함수의 호출 스택의 최대 깊이를 생각해보면 `O(r * c)`라는 것을 알 수 있습니다.

## 풀이 2

이 문제는 결국 그래프 내에서 정점 간의 최소 거리를 구하는 문제이므로 너비 우선 탐색을 하면 훨씬 효과적으로 해결할 수 있을 것입니다.

기본 아이디어는 주어진 행렬 내에서 `0`이 들어있는 칸부터 시작해서 `0`이 들어있지 않는 칸을 향해서 거리를 1씩 늘려가면서 탐색을 하는 건데요.
이렇게 하면 `0`이 아닌 셀에 제일 먼저 도달했을 때의 거리가 무조건 해당 셀과 `0` 간의 가장 가까운 거리라고 확신할 수 있습니다.
그러므로 `0`이 들어있는 다른 셀에서 해당 셀에 도착할 수 있는 경로를 모두 배재해버릴 수 있겠죠?
즉, 너비 우선 탐색을 통해서 연산량을 획기적으로 줄이고 훨씬 빨리 최소 거리를 찾을 수 있습니다.

우선 큐에 0이 들어있는 칸의 좌표를 추가합니다.

```py
큐: [(0, 0), (0, 1), (0, 2), (1, 0), (1, 2)]
```

큐에서 `(0, 0)`을 제거하고, 행렬에서 이 위치 기준으로 사방을 살핍니다.
위와 왼쪽은 칸이 없고, 아래와 오른쪽 칸에는 `0`이 들어있는데요.
그럼 굳이 여기서 부터 거리를 젤 필요가 없습니다.
어차피 아래와 오른쪽 칸에서 `0`과 가장 가까운 거리는 `0`이 될테니까요.

```py
(0, 0) 제거

큐: [(0, 1), (0, 2), (1, 0), (1, 2)]
행렬:
[0, 0, 0]
[0, ?, 0]
[?, ?, ?]
```

다음에는 큐에서 `(0, 1)`을 제거하고, 행렬에서 이 위치 기준으로 사방을 살핍니다.
위에는 칸이 없고, 좌우 칸에는 `0`이 들어있으며, 아래 칸에는 최대 거리인 `?`가 들어있는데요.
따라서 여기서 부터 아래 칸과의 거리인 `1`로 갱신해줍니다.
나중에 아래 칸에서 부터 거리를 젤 수 있도록 아래 칸의 위치인 `(1, 1)`을 큐에 추가합니다.

```py
(0, 1) 제거
mat[1][1] = mat[0][1] + 1 = 0 + 1 = 1
(1, 1) 추가

큐: [(0, 2), (1, 0), (1, 2), (1, 1)]
행렬:
[0, 0, 0]
[0, 1, 0]
[?, ?, ?]
```

다음에는 큐에서 `(0, 2)`를 제거하고, 행렬에서 이 위치 기준으로 사방을 살핍니다.
위와 오른쪽에는 칸이 없고, 아래와 왼쪽에는 `0`이 들어있네요.
그럼 굳이 여기서 부터 거리를 젤 이유가 없으므로 넘어갑니다.

```py
(0, 2) 제거

큐: [(1, 0), (1, 2), (1, 1)]
행렬:
[0, 0, 0]
[0, 1, 0]
[?, ?, ?]
```

다음에는 큐에서 `(1, 0)`을 제거하고, 행렬에서 이 위치 기준으로 사방을 살핍니다.
왼쪽에는 칸이 없고, 위에 있는 칸에는 `0`이 있습니다.
우측 칸에는 `1`이 들어있는데요.
여기서 부터 출발한다고 해도 거리가 `1`이 될 것이므로 이미 가장 가까운 거리가 들어있다는 것을 알 수 있습니다.
아래 칸에는 `?`가 들어있는데요.
이 `0`이 있는 위치와 아래 칸의 거리인 `1`로 갱신할 수 있습니다.
나중에 아래 칸에서 부터 거리를 젤 수 있도록 아래 칸의 위치인 `(2, 0)`을 큐에 추가합니다.

```py
(1, 0) 제거
mat[2][0] = mat[1][0] + 1 = 0 + 1 = 1
(2, 0) 추가

큐: [(1, 2), (1, 1), (2, 0)]
행렬:
[0, 0, 0]
[0, 1, 0]
[1, ?, ?]
```

큐에서 `(1, 2)`을 제거하고, 이 위치 기준으로 사방을 살핍니다.
아래 칸에 `?`가 들어있으니, 이 칸과의 거리인 `1`로 갱신할 수 있습니다.

```py
(1, 2) 제거
mat[2][2] = mat[1][2] + 1 = 0 + 1 = 1
(2, 2) 추가

큐: [(1, 1), (2, 0), (2, 2)]
행렬:
[0, 0, 0]
[0, 1, 0]
[1, ?, 1]
```

큐에서 `(1, 1)`을 제거하고, 이 위치 기준으로 사방을 살핍니다.
상, 좌, 우는 `0`이지만, 아래에는 `?`가 있습니다.
아래 칸을 이 `1`이 있는 위치의 거리인 `2`로 갱신할 수 있습니다.
나중에 아래 칸에서 부터 거리를 젤 수 있도록 아래 칸의 위치인 `(2, 1)`을 큐에 추가합니다.

```py
(1, 1) 제거
mat[2][1] = mat[1][1] + 1 = 1 + 1 = 2
(2, 1) 추가

큐: [(2, 0), (2, 2), (2, 1)]
행렬:
[0, 0, 0]
[0, 1, 0]
[1, 2, 1]
```

큐에서 `(2, 0)`을 제거하고, 이 위치 기준으로 사방을 살핍니다.
위에 `0`있고, 오른쪽에 `2`가 있는데, 모두 최대 거리가 아닌므로 넘어갑니다.

```py
(2, 0) 제거

큐: [(2, 2), (2, 1)]
행렬:
[0, 0, 0]
[0, 1, 0]
[1, 2, 1]
```

큐에서 `(2, 2)`을 제거하고, 이 위치 기준으로 사방을 살핍니다.
위에 `0`있고, 왼쪽에 `2`가 있는데, 모두 최대 거리가 아닌므로 넘어갑니다.

```py
(2, 2) 제거

[(2, 1)]
행렬:
[0, 0, 0]
[0, 1, 0]
[1, 2, 1]
```

큐에서 `(2, 2)`을 제거하고, 이 위치 기준으로 사방을 살핍니다.
상, 좌, 우 모두 `1`이 있으며, 최대 거리가 아니므로 넘어감니다.

```py
(2, 1) 제거

[]
행렬:
[0, 0, 0]
[0, 1, 0]
[1, 2, 1]
```

이제 큐가 비었기 때문에 더 이상 거리를 따져볼 좌표가 없습니다.

지금까지 설명드린 너비 우선 탐색 알고리즘을 파이썬으로 구현해볼까요?
[큐(Queue)](/data-structures/queue/) 자료구조가 필요하기 때문에 파이썬에 내장된 `collections` 모듈의 `deque`를 사용하겠습니다.

```py
from collections import deque


class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        n_rows, n_cols = len(mat), len(mat[0])
        queue = deque()

        for r in range(n_rows):
            for c in range(n_cols):
                if mat[r][c] == 0:
                    queue.append((r, c))
                else:
                    mat[r][c] = -1 # 아직 구하지 않은 최소 거리

        while queue:
            row, col = queue.popleft()

            for r, c in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                if 0 <= row + r < n_rows and 0 <= col + c < n_cols:
                    if mat[row + r][col + c] == -1:
                        mat[row + r][col + c] = mat[row][col] + 1
                        queue.append((row + r, col + c))

        return mat
```

이 풀이의 시간 복잡도는 `O(r * c)`로 향상이 됩니다.
왜냐하면 각 좌표는 큐에 딱 한 번만 들어갔다가 나오기 때문입니다.
공간 복잡도는 큐에 최대 `r * c` 개의 좌표가 저장될 수 있으므로 `O(r * c)`이 됩니다.
