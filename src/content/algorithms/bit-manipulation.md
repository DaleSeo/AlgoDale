---
title: "비트 조작 (Bit Manipulation)"
tags:
  - bit-manipulation
  - python
  - java
date: 2024-01-02
---

컴퓨터는 기계어 수준까지 내려가면 결국 모든 데이터를 `0`과 `1`처리합니다.
따라서 전산학에서는 오래 전부터 데이터를 일련의 비트로 다루는 능력을 중요시했었습니다.

현대 프로그래밍에서 비트 조작이 여전히 중요한지에 대해서는 분야마다 의견이 많이 갈리고 있지만,
적어도 코딩 테스트에서는 지원자가 비트 잘 다룰 수 있는지 시험하는 문제가 종종 나오기 때문에 준비가 필요합니다.

## 비트 연산자

코딩 테스트에서 비트 조작은 비트 연산자(Bitwise Operator)를 조합해서 이루어집니다.
그래서 각 이진 연산자의 특징을 정확하게 이해하는 것이 중요한데요.

`~` 연산자는 부정(NOT)을 나타내며 `0`은 `1`로 바꾸고 `1`은 `0`로 바꿔서 반환합니다.
예를 들어, `~5`은 `~0101`이 되어 `1010`, 즉 `10`이 됩니다.

`&` 연산자는 논라곱(AND)을 나타내며 두 비트가 모두 `1`일 때만 `1`을 반환합니다.
다시 말해서 두 비트 중 하나라도 `0`이면 `0`을 반환합니다
예를 들어, `5 & 3`은 `0101 & 0011`이 되어 `0001`, 즉 `1`이 됩니다.

`|` 연산자는 논리합(OR)을 나타내며 두 비트 중 하나라도 `1`이면 `1`을 반환합니다.
다시 말해서 두 비트가 모두 `0`일 때만 `0`을 반환합니다.
예를 들어, `5 | 3`은 `0101 | 0011`이 되어 `0111`, 즉 `7`이 됩니다.

`^` 연산자는 배타적 논리합(XOR)을 나타내며 두 비트가 서로 다를 때만 `1`을 반환합니다.
다시 말해서 두 비트가 동일할 때만 `0`을 반환합니다.
예를 들어, `5 ^ 3`은 `0101 ^ 0011`이 되어 `0110`, 즉 `6`이 됩니다.

특히 `^` 연산자는 특히 코딩 테스트에서 중복값을 제거하거나 유일한 값을 찾을 때 활용할 수 있습니다.
두 개의 동일한 값을 `^` 연산자로 엮으면 `0`이 되기 때문입니다.

`<<` 연산자는 왼쪽 시프트를 나타내며 비트를 왼쪽으로 이동합니다.
예를 들어, `5 << 1`은 `0101 << 1`이 되어 `1010`, 즉 `10`이 됩니다.
`x << y`는 `x * 2^y`한 효과를 발휘해서 곱하기 대신에 사용하기도 합니다.

`>>` 연산자는 오른쪽 시프트를 나타내며 비트를 오른쪽으로 이동합니다.
예를 들어, `5 >> 1`은 `0101 >> 1`이 되어 `0010`, 즉 `2`가 됩니다.
`x >> y`는 `x // 2^y`한 효과를 발휘해서 나누기 대신에 사용하기도 합니다.

## 2의 보수 표현법

컴퓨터에서 어떻게 `0`과 `1`로 숫자를 표현할 수 있는지 알아보겠습니다.

간단하게 4비트로 표현할 수 있는 숫자를 생각해볼까요?
2의 4승을 하면 총 16개의 숫자를 표현할 수 있을텐데요.

양수를 `0`과 `1`로 표현하는 것은 딱히 어렵지 않은데요.
학창 시절 수학 시간에 이진수를 떠올리시면 될 것 같습니다.

| 숫자 | 비트 표현 |
| ---- | --------- |
| 0    | 0000      |
| 1    | 0001      |
| 2    | 0010      |
| 3    | 0011      |
| 4    | 0100      |
| 5    | 0101      |
| 6    | 0110      |
| 7    | 0111      |

음수를 `0`과 `1`로 표현하는 것은 살짝 더 어려울 수 있는데요.
보통 컴퓨터에서는 2의 보수(Two's complement) 표현법을 사용하여 음수를 비트로 표현합니다.

음수 `-x`를 비트로 표현할 때는 먼저 `x - 1`의 비트를 구한 후에 비트를 반전(`0`은 `1`로, `1`은 `0`으로 변경)시키면 됩니다.
수식으로 표현하면 `-x = ~(x - 1)`이 됩니다.

예를 들어, `-3`의 경우, `3 - 1`, 즉 2의 비트는 `0010`이 되는데요.
이를 반전시키면 `1101`이 됩니다.

| 숫자 | 비트 표현 |
| ---- | --------- |
| -1   | 1111      |
| -2   | 1110      |
| -3   | 1101      |
| -4   | 1100      |
| -5   | 1011      |
| -6   | 1010      |
| -7   | 1001      |
| -8   | 1000      |

위 두개의 테이블 비교해보면 양수인 `0`부터 `7`의 최상위 비트는 `0`이고, 음수인 `-8`부터 `-1`의 최상위 비트는 `1`이라는 것을 알 수 있습니다.
따라서 2의 보수 표현법에서는 최상위 비트를 보고 양수인지 음수인지 판단할 수 있습니다.

이렇게 4비트로는 `-8`부터 `7`까지 숫자를 표현할 수 있습니다.
8비트로는 `-129`부터 `128`까지 숫자를 표현할 수 있을 것입니다.

## 추천 문제

비트 조작의 기초를 다지시는데 아래 문제를 추천드리겠습니다.

- [Number of 1 Bits](/problems/number-of-1-bits/)
- [Reverse Bits](/problems/reverse-bits/)
- [Counting Bits](/problems/counting-bits/)
- [Sum of Two Integers](/problems/sum-of-two-integers/)
